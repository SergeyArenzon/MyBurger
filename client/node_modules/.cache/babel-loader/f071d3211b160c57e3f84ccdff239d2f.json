{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar kErrorLabels = Symbol('errorLabels');\n/**\n * Creates a new MongoError\n *\n * @augments Error\n * @param {Error|string|object} message The error message\n * @property {string} message The error message\n * @property {string} stack The error call stack\n */\n\nvar MongoError = /*#__PURE__*/function (_Error) {\n  _inherits(MongoError, _Error);\n\n  function MongoError(message) {\n    var _this;\n\n    _classCallCheck(this, MongoError);\n\n    if (message instanceof Error) {\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoError).call(this, message.message));\n      _this.stack = message.stack;\n    } else {\n      if (typeof message === 'string') {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoError).call(this, message));\n      } else {\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoError).call(this, message.message || message.errmsg || message.$err || 'n/a'));\n\n        if (message.errorLabels) {\n          _this[kErrorLabels] = new Set(message.errorLabels);\n        }\n\n        for (var name in message) {\n          if (name === 'errorLabels' || name === 'errmsg') {\n            continue;\n          }\n\n          _this[name] = message[name];\n        }\n      }\n\n      Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    }\n\n    _this.name = 'MongoError';\n    return _possibleConstructorReturn(_this);\n  }\n  /**\n   * Legacy name for server error responses\n   */\n\n\n  _createClass(MongoError, [{\n    key: \"hasErrorLabel\",\n\n    /**\n     * Checks the error to see if it has an error label\n     * @param {string} label The error label to check for\n     * @returns {boolean} returns true if the error has the provided error label\n     */\n    value: function hasErrorLabel(label) {\n      if (this[kErrorLabels] == null) {\n        return false;\n      }\n\n      return this[kErrorLabels].has(label);\n    }\n  }, {\n    key: \"addErrorLabel\",\n    value: function addErrorLabel(label) {\n      if (this[kErrorLabels] == null) {\n        this[kErrorLabels] = new Set();\n      }\n\n      this[kErrorLabels].add(label);\n    }\n  }, {\n    key: \"errmsg\",\n    get: function get() {\n      return this.message;\n    }\n    /**\n     * Creates a new MongoError object\n     *\n     * @param {Error|string|object} options The options used to create the error.\n     * @return {MongoError} A MongoError instance\n     * @deprecated Use `new MongoError()` instead.\n     */\n\n  }, {\n    key: \"errorLabels\",\n    get: function get() {\n      return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];\n    }\n  }], [{\n    key: \"create\",\n    value: function create(options) {\n      return new MongoError(options);\n    }\n  }]);\n\n  return MongoError;\n}(_wrapNativeSuper(Error));\n\nvar kBeforeHandshake = Symbol('beforeHandshake');\n\nfunction isNetworkErrorBeforeHandshake(err) {\n  return err[kBeforeHandshake] === true;\n}\n/**\n * An error indicating an issue with the network, including TCP\n * errors and timeouts.\n *\n * @param {Error|string|object} message The error message\n * @property {string} message The error message\n * @property {string} stack The error call stack\n * @extends MongoError\n */\n\n\nvar MongoNetworkError = /*#__PURE__*/function (_MongoError) {\n  _inherits(MongoNetworkError, _MongoError);\n\n  function MongoNetworkError(message, options) {\n    var _this2;\n\n    _classCallCheck(this, MongoNetworkError);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MongoNetworkError).call(this, message));\n    _this2.name = 'MongoNetworkError';\n\n    if (options && options.beforeHandshake === true) {\n      _this2[kBeforeHandshake] = true;\n    }\n\n    return _this2;\n  }\n\n  return MongoNetworkError;\n}(MongoError);\n/**\n * An error indicating a network timeout occurred\n *\n * @param {Error|string|object} message The error message\n * @property {string} message The error message\n * @property {object} [options.beforeHandshake] Indicates the timeout happened before a connection handshake completed\n * @extends MongoError\n */\n\n\nvar MongoNetworkTimeoutError = /*#__PURE__*/function (_MongoNetworkError) {\n  _inherits(MongoNetworkTimeoutError, _MongoNetworkError);\n\n  function MongoNetworkTimeoutError(message, options) {\n    var _this3;\n\n    _classCallCheck(this, MongoNetworkTimeoutError);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(MongoNetworkTimeoutError).call(this, message, options));\n    _this3.name = 'MongoNetworkTimeoutError';\n    return _this3;\n  }\n\n  return MongoNetworkTimeoutError;\n}(MongoNetworkError);\n/**\n * An error used when attempting to parse a value (like a connection string)\n *\n * @param {Error|string|object} message The error message\n * @property {string} message The error message\n * @extends MongoError\n */\n\n\nvar MongoParseError = /*#__PURE__*/function (_MongoError2) {\n  _inherits(MongoParseError, _MongoError2);\n\n  function MongoParseError(message) {\n    var _this4;\n\n    _classCallCheck(this, MongoParseError);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(MongoParseError).call(this, message));\n    _this4.name = 'MongoParseError';\n    return _this4;\n  }\n\n  return MongoParseError;\n}(MongoError);\n/**\n * An error signifying a client-side timeout event\n *\n * @param {Error|string|object} message The error message\n * @param {string|object} [reason] The reason the timeout occured\n * @property {string} message The error message\n * @property {string} [reason] An optional reason context for the timeout, generally an error saved during flow of monitoring and selecting servers\n * @extends MongoError\n */\n\n\nvar MongoTimeoutError = /*#__PURE__*/function (_MongoError3) {\n  _inherits(MongoTimeoutError, _MongoError3);\n\n  function MongoTimeoutError(message, reason) {\n    var _this5;\n\n    _classCallCheck(this, MongoTimeoutError);\n\n    if (reason && reason.error) {\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MongoTimeoutError).call(this, reason.error.message || reason.error));\n    } else {\n      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MongoTimeoutError).call(this, message));\n    }\n\n    _this5.name = 'MongoTimeoutError';\n\n    if (reason) {\n      _this5.reason = reason;\n    }\n\n    return _possibleConstructorReturn(_this5);\n  }\n\n  return MongoTimeoutError;\n}(MongoError);\n/**\n * An error signifying a client-side server selection error\n *\n * @param {Error|string|object} message The error message\n * @param {string|object} [reason] The reason the timeout occured\n * @property {string} message The error message\n * @property {string} [reason] An optional reason context for the timeout, generally an error saved during flow of monitoring and selecting servers\n * @extends MongoError\n */\n\n\nvar MongoServerSelectionError = /*#__PURE__*/function (_MongoTimeoutError) {\n  _inherits(MongoServerSelectionError, _MongoTimeoutError);\n\n  function MongoServerSelectionError(message, reason) {\n    var _this6;\n\n    _classCallCheck(this, MongoServerSelectionError);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(MongoServerSelectionError).call(this, message, reason));\n    _this6.name = 'MongoServerSelectionError';\n    return _this6;\n  }\n\n  return MongoServerSelectionError;\n}(MongoTimeoutError);\n\nfunction makeWriteConcernResultObject(input) {\n  var output = Object.assign({}, input);\n\n  if (output.ok === 0) {\n    output.ok = 1;\n    delete output.errmsg;\n    delete output.code;\n    delete output.codeName;\n  }\n\n  return output;\n}\n/**\n * An error thrown when the server reports a writeConcernError\n *\n * @param {Error|string|object} message The error message\n * @param {object} result The result document (provided if ok: 1)\n * @property {string} message The error message\n * @property {object} [result] The result document (provided if ok: 1)\n * @extends MongoError\n */\n\n\nvar MongoWriteConcernError = /*#__PURE__*/function (_MongoError4) {\n  _inherits(MongoWriteConcernError, _MongoError4);\n\n  function MongoWriteConcernError(message, result) {\n    var _this7;\n\n    _classCallCheck(this, MongoWriteConcernError);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(MongoWriteConcernError).call(this, message));\n    _this7.name = 'MongoWriteConcernError';\n\n    if (result && Array.isArray(result.errorLabels)) {\n      _this7[kErrorLabels] = new Set(result.errorLabels);\n    }\n\n    if (result != null) {\n      _this7.result = makeWriteConcernResultObject(result);\n    }\n\n    return _this7;\n  }\n\n  return MongoWriteConcernError;\n}(MongoError); // see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms\n\n\nvar RETRYABLE_ERROR_CODES = new Set([6, // HostUnreachable\n7, // HostNotFound\n89, // NetworkTimeout\n91, // ShutdownInProgress\n189, // PrimarySteppedDown\n9001, // SocketException\n10107, // NotMaster\n11600, // InterruptedAtShutdown\n11602, // InterruptedDueToReplStateChange\n13435, // NotMasterNoSlaveOk\n13436 // NotMasterOrSecondary\n]);\nvar RETRYABLE_WRITE_ERROR_CODES = new Set([11600, // InterruptedAtShutdown\n11602, // InterruptedDueToReplStateChange\n10107, // NotMaster\n13435, // NotMasterNoSlaveOk\n13436, // NotMasterOrSecondary\n189, // PrimarySteppedDown\n91, // ShutdownInProgress\n7, // HostNotFound\n6, // HostUnreachable\n89, // NetworkTimeout\n9001, // SocketException\n262 // ExceededTimeLimit\n]);\n\nfunction isRetryableWriteError(error) {\n  if (error instanceof MongoWriteConcernError) {\n    return RETRYABLE_WRITE_ERROR_CODES.has(error.code) || RETRYABLE_WRITE_ERROR_CODES.has(error.result.code);\n  }\n\n  return RETRYABLE_WRITE_ERROR_CODES.has(error.code);\n}\n/**\n * Determines whether an error is something the driver should attempt to retry\n *\n * @ignore\n * @param {MongoError|Error} error\n */\n\n\nfunction isRetryableError(error) {\n  return RETRYABLE_ERROR_CODES.has(error.code) || error instanceof MongoNetworkError || error.message.match(/not master/) || error.message.match(/node is recovering/);\n}\n\nvar SDAM_RECOVERING_CODES = new Set([91, // ShutdownInProgress\n189, // PrimarySteppedDown\n11600, // InterruptedAtShutdown\n11602, // InterruptedDueToReplStateChange\n13436 // NotMasterOrSecondary\n]);\nvar SDAM_NOTMASTER_CODES = new Set([10107, // NotMaster\n13435 // NotMasterNoSlaveOk\n]);\nvar SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([11600, // InterruptedAtShutdown\n91 // ShutdownInProgress\n]);\n\nfunction isRecoveringError(err) {\n  if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {\n    return true;\n  }\n\n  return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);\n}\n\nfunction isNotMasterError(err) {\n  if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {\n    return true;\n  }\n\n  if (isRecoveringError(err)) {\n    return false;\n  }\n\n  return err.message.match(/not master/);\n}\n\nfunction isNodeShuttingDownError(err) {\n  return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);\n}\n/**\n * Determines whether SDAM can recover from a given error. If it cannot\n * then the pool will be cleared, and server state will completely reset\n * locally.\n *\n * @ignore\n * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering\n * @param {MongoError|Error} error\n */\n\n\nfunction isSDAMUnrecoverableError(error) {\n  // NOTE: null check is here for a strictly pre-CMAP world, a timeout or\n  //       close event are considered unrecoverable\n  if (error instanceof MongoParseError || error == null) {\n    return true;\n  }\n\n  if (isRecoveringError(error) || isNotMasterError(error)) {\n    return true;\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  MongoError: MongoError,\n  MongoNetworkError: MongoNetworkError,\n  MongoNetworkTimeoutError: MongoNetworkTimeoutError,\n  MongoParseError: MongoParseError,\n  MongoTimeoutError: MongoTimeoutError,\n  MongoServerSelectionError: MongoServerSelectionError,\n  MongoWriteConcernError: MongoWriteConcernError,\n  isRetryableError: isRetryableError,\n  isSDAMUnrecoverableError: isSDAMUnrecoverableError,\n  isNodeShuttingDownError: isNodeShuttingDownError,\n  isRetryableWriteError: isRetryableWriteError,\n  isNetworkErrorBeforeHandshake: isNetworkErrorBeforeHandshake\n};","map":null,"metadata":{},"sourceType":"script"}