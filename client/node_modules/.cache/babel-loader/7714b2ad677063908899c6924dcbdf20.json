{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _defineProperty = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _makeStateMachine;\n\nvar ServerType = require('./common').ServerType;\n\nvar EventEmitter = require('events');\n\nvar connect = require('../connection/connect');\n\nvar Connection = require('../../cmap/connection').Connection;\n\nvar common = require('./common');\n\nvar makeStateMachine = require('../utils').makeStateMachine;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar BSON = require('../connection/utils').retrieveBSON();\n\nvar makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\n\nvar calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\nvar now = require('../../utils').now;\n\nvar sdamEvents = require('./events');\n\nvar ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nvar ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nvar ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nvar kServer = Symbol('server');\nvar kMonitorId = Symbol('monitorId');\nvar kConnection = Symbol('connection');\nvar kCancellationToken = Symbol('cancellationToken');\nvar kRTTPinger = Symbol('rttPinger');\nvar kRoundTripTime = Symbol('roundTripTime');\nvar STATE_CLOSED = common.STATE_CLOSED;\nvar STATE_CLOSING = common.STATE_CLOSING;\nvar STATE_IDLE = 'idle';\nvar STATE_MONITORING = 'monitoring';\nvar stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_IDLE, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_MONITORING]), _defineProperty(_makeStateMachine, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, STATE_CLOSING]), _defineProperty(_makeStateMachine, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]), _makeStateMachine));\nvar INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nvar Monitor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Monitor, _EventEmitter);\n\n  function Monitor(server, options) {\n    var _this;\n\n    _classCallCheck(this, Monitor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Monitor).call(this, options));\n    _this[kServer] = server;\n    _this[kConnection] = undefined;\n    _this[kCancellationToken] = new EventEmitter();\n\n    _this[kCancellationToken].setMaxListeners(Infinity);\n\n    _this[kMonitorId] = null;\n    _this.s = {\n      state: STATE_CLOSED\n    };\n    _this.address = server.description.address;\n    _this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    var connectOptions = Object.assign({\n      id: '<monitor>',\n      host: server.description.host,\n      port: server.description.port,\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, _this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n    _this.connectOptions = Object.freeze(connectOptions);\n    return _this;\n  }\n\n  _createClass(Monitor, [{\n    key: \"connect\",\n    value: function connect() {\n      if (this.s.state !== STATE_CLOSED) {\n        return;\n      } // start\n\n\n      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n        interval: heartbeatFrequencyMS,\n        minInterval: minHeartbeatFrequencyMS,\n        immediate: true\n      });\n    }\n  }, {\n    key: \"requestCheck\",\n    value: function requestCheck() {\n      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n        return;\n      }\n\n      this[kMonitorId].wake();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (isInCloseState(this)) {\n        return;\n      }\n\n      stateTransition(this, STATE_CLOSING);\n      resetMonitorState(this); // restart monitor\n\n      stateTransition(this, STATE_IDLE); // restart monitoring\n\n      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n      this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n        interval: heartbeatFrequencyMS,\n        minInterval: minHeartbeatFrequencyMS\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (isInCloseState(this)) {\n        return;\n      }\n\n      stateTransition(this, STATE_CLOSING);\n      resetMonitorState(this); // close monitor\n\n      this.emit('close');\n      stateTransition(this, STATE_CLOSED);\n    }\n  }]);\n\n  return Monitor;\n}(EventEmitter);\n\nfunction resetMonitorState(monitor) {\n  stateTransition(monitor, STATE_CLOSING);\n\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({\n      force: true\n    });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  var start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({\n        force: true\n      });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    var connectTimeoutMS = monitor.options.connectTimeoutMS;\n    var maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    var topologyVersion = monitor[kServer].description.topologyVersion;\n    var isAwaitable = topologyVersion != null;\n    var cmd = isAwaitable ? {\n      ismaster: true,\n      maxAwaitTimeMS: maxAwaitTimeMS,\n      topologyVersion: makeTopologyVersion(topologyVersion)\n    } : {\n      ismaster: true\n    };\n    var options = isAwaitable ? {\n      socketTimeout: connectTimeoutMS + maxAwaitTimeMS,\n      exhaustAllowed: true\n    } : {\n      socketTimeout: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, function (err, result) {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      var isMaster = result.result;\n      var duration = isAwaitable ? monitor[kRTTPinger].roundTripTime : calculateDurationInMs(start);\n      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], function (err, conn) {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return function (callback) {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    } // TODO: the next line is a legacy event, remove in v4\n\n\n    process.nextTick(function () {\n      return monitor.emit('monitoring', monitor[kServer]);\n    });\n    checkServer(monitor, function (err, isMaster) {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(function () {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nvar RTTPinger = /*#__PURE__*/function () {\n  function RTTPinger(cancellationToken, options) {\n    var _this2 = this;\n\n    _classCallCheck(this, RTTPinger);\n\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    var heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(function () {\n      return measureRoundTripTime(_this2, options);\n    }, heartbeatFrequencyMS);\n  }\n\n  _createClass(RTTPinger, [{\n    key: \"close\",\n    value: function close() {\n      this.closed = true;\n      clearTimeout(this[kMonitorId]);\n      this[kMonitorId] = undefined;\n\n      if (this[kConnection]) {\n        this[kConnection].destroy({\n          force: true\n        });\n      }\n    }\n  }, {\n    key: \"roundTripTime\",\n    get: function get() {\n      return this[kRoundTripTime];\n    }\n  }]);\n\n  return RTTPinger;\n}();\n\nfunction measureRoundTripTime(rttPinger, options) {\n  var start = now();\n  var cancellationToken = rttPinger[kCancellationToken];\n  var heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(function () {\n      return measureRoundTripTime(rttPinger, options);\n    }, heartbeatFrequencyMS);\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, function (err, conn) {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', {\n    ismaster: 1\n  }, function (err) {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor: Monitor\n};","map":null,"metadata":{},"sourceType":"script"}