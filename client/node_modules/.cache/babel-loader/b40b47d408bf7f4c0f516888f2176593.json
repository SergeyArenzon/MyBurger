{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/sergey/Dev/Web/myburger/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar crypto = require('crypto');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar MongoError = require('../error').MongoError;\n\nvar AuthProvider = require('./auth_provider').AuthProvider;\n\nvar BSON = retrieveBSON();\nvar Binary = BSON.Binary;\nvar saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar ScramSHA = /*#__PURE__*/function (_AuthProvider) {\n  _inherits(ScramSHA, _AuthProvider);\n\n  function ScramSHA(bson, cryptoMethod) {\n    var _this;\n\n    _classCallCheck(this, ScramSHA);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA).call(this, bson));\n    _this.cryptoMethod = cryptoMethod || 'sha1';\n    return _this;\n  }\n\n  _createClass(ScramSHA, [{\n    key: \"prepare\",\n    value: function prepare(handshakeDoc, authContext, callback) {\n      var cryptoMethod = this.cryptoMethod;\n\n      if (cryptoMethod === 'sha256' && saslprep == null) {\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n\n      crypto.randomBytes(24, function (err, nonce) {\n        if (err) {\n          return callback(err);\n        } // store the nonce for later use\n\n\n        Object.assign(authContext, {\n          nonce: nonce\n        });\n        var credentials = authContext.credentials;\n        var request = Object.assign({}, handshakeDoc, {\n          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n            db: credentials.source\n          })\n        });\n        callback(undefined, request);\n      });\n    }\n  }, {\n    key: \"auth\",\n    value: function auth(authContext, callback) {\n      var response = authContext.response;\n\n      if (response && response.speculativeAuthenticate) {\n        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n        return;\n      }\n\n      executeScram(this.cryptoMethod, authContext, callback);\n    }\n  }]);\n\n  return ScramSHA;\n}(AuthProvider);\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  var username = cleanUsername(credentials.username);\n  var mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256'; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism: mechanism,\n    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  var connection = authContext.connection;\n  var credentials = authContext.credentials;\n  var nonce = authContext.nonce;\n  var db = credentials.source;\n  var saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(\"\".concat(db, \".$cmd\"), saslStartCmd, function (_err, result) {\n    var err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  var connection = authContext.connection;\n  var credentials = authContext.credentials;\n  var nonce = authContext.nonce;\n  var db = credentials.source;\n  var username = cleanUsername(credentials.username);\n  var password = credentials.password;\n  var processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  var payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;\n  var dict = parsePayload(payload.value());\n  var iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(\"Server returned an invalid iteration count \".concat(iterations)), false);\n    return;\n  }\n\n  var salt = dict.s;\n  var rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(\"Server returned an invalid nonce: \".concat(rnonce)), false);\n    return;\n  } // Set up start of proof\n\n\n  var withoutProof = \"c=biws,r=\".concat(rnonce);\n  var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  var storedKey = H(cryptoMethod, clientKey);\n  var authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');\n  var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  var clientProof = \"p=\".concat(xor(clientKey, clientSignature));\n  var clientFinal = [withoutProof, clientProof].join(',');\n  var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  var saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n  connection.command(\"\".concat(db, \".$cmd\"), saslContinueCmd, function (_err, result) {\n    var err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    var r = result.result;\n    var parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    var retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(\"\".concat(db, \".$cmd\"), retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  var md5 = crypto.createHash('md5');\n  md5.update(\"\".concat(username, \":mongo:\").concat(password), 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  var length = Math.max(a.length, b.length);\n  var res = [];\n\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  var result = 0;\n\n  for (var i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n  var r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nvar ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n\n  function ScramSHA1(bson) {\n    _classCallCheck(this, ScramSHA1);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, bson, 'sha1'));\n  }\n\n  return ScramSHA1;\n}(ScramSHA);\n\nvar ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n\n  function ScramSHA256(bson) {\n    _classCallCheck(this, ScramSHA256);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, bson, 'sha256'));\n  }\n\n  return ScramSHA256;\n}(ScramSHA);\n\nmodule.exports = {\n  ScramSHA1: ScramSHA1,\n  ScramSHA256: ScramSHA256\n};","map":null,"metadata":{},"sourceType":"script"}